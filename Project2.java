import java.util.*;
/** 
 * This project is designed as a single class project2.
 * @author    Jingsong Sun <jsun18@toromail.csudh.edu>
 * @version   1.1
 * <h1>Data</h1>
 * <p>Using a 2-D array int[][] graph to represent the graph.
 * The value in the cell represent the weight of 2 nodes.
 * If the weight is 0 means that these two nodes are not connected.
 * </p>
 * <h1>The implementing process</h1>
 * <h2>1. Generate graph</h2>
 * <p> User input the number of nodes.
 *     The probability to generate an edge between 2 nodes is set to 25% using random method.
 *     The weight is also be generated by Random object with range 1~5*number of nodes.
 *     If the generated graph is not connected, the program will continue to use while loop
 *     to generate another graphs until the generated graph is connected.
 * </p>
 * <h1>2. Yen's Algorithm</h1>
 * <h1>3. Display the kth shortest paths</h1>   
 */
public class Project2 {
	// Using a 2-D array to represent a graph
	int[][] graph;
	
	
	/**
	 * Generate a 2-D array to represent a graph. 
	 * User input the number of nodes, this method generate a connected graph with weight
	 */
	public void generateEdges() {
		Scanner sc = new Scanner(System.in);
		System.out.println("Please enter the number of nodes: ");
		int num = sc.nextInt();
		
		// Generating graph with all vertices connected
		boolean isConnected = false;
		while (!isConnected) {
		    graph = new int[num][num];
		    Random rand = new Random();
		    for (int i = 0; i < num; i++) {
			    for (int j = i + 1; j < num; j++) {
			    	// The probability of two nodes connected is 25%
				    double random = (rand.nextDouble())*100;
				    if (random < 25) {
					    // The weight range is 1 ~ 5 * num
					    graph[i][j] = rand.nextInt(5* num + 1) + 1;
				    }
			    }
		    }
		    // Check if the graph is connected
		    isConnected = bfs(0);
	    }
		
		// Display the generated graph
		System.out.println("The input graph as below: ");
		// Display Node List
		System.out.print("Node list: {");
		for (int v = 0; v < num; v++) {
			System.out.print(v + 1);
			if (v < num - 1) {
			    System.out.print(",");
		    }
		}
		System.out.print("}");
		System.out.println();
		// Display Edge List
		String edgeStr = "";
		
	    edgeStr += "Edge list: {";
		for (int row = 0; row < num; row++) {
			for (int col = 0; col < num; col++) {
				if (graph[row][col] > 0) {
					edgeStr += "(" + (row + 1) + "," +(col + 1) + "," + graph[row][col] + ")";
					edgeStr += ",";
				}
				
			}
		}
		int last = edgeStr.length() - 1;
		char ch = edgeStr.charAt(last);
		edgeStr = ch == ','? edgeStr.substring(0, last) + "}": edgeStr + "}";
	    System.out.println(edgeStr);
	    
	    // Reconstruct Array to generate an undirected graph
	    for (int i = 0; i < num; i++) {
		    for (int j = i + 1; j < num; j++) {
				 graph[j][i] = graph[i][j];
				 if (graph[j][i] > 0) {
				    	
				 }
		    }
	    }
	}// end of generateEdge
	
	
	/** To determine if the generated graph is connected.
	 *  @param s represent the source node(Here we pass the first node)
	 *  @return true if the graph is connected else false 
	 */
	boolean bfs(int s) {
		// Marking all the vertices as false(unvisited) except 0
		boolean visited[] = new boolean[graph.length];
		// Create a queue for BFS 
		Queue<Integer> queue = new LinkedList<Integer>(); 
		  
		// Mark the current node as visited and enqueue it 
		visited[s]=true; 
		queue.add(s); 
		
		while (!queue.isEmpty()) { 
		    // Dequeue a vertex from queue
		    int index = queue.poll(); 
		    /* Get all adjacent vertices of the dequeued vertex s 
		       If a adjacent has not been visited, then mark it 
		     visited and enqueue it */
		   for (int i = 0; i < graph.length; i++) {
		        int n = graph[index][i]; 
		        if (!visited[i] && n > 0) { 
		            visited[i] = true; 
		            queue.add(i); 
		        } 
		    } 
		}
		// If there exists nodes which are unvisited, then the graph is not connected
		for (boolean b: visited) {
			if (b == false) return false;
		}
		return true;
	}// end bfs()
	
	
	/** Input source node, source node , sink node, 
	 * and number of k for kth shortest path */
	public void ksp() {
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the source node(1~n): ");
		int s = sc.nextInt();
		System.out.println("Enter the sink node(1~n): ");
		int d = sc.nextInt();
		System.out.println("Enter the number of shortest paths: ");
		int k = sc.nextInt();
		ArrayList<ArrayList<int[]>> paths = yenAlgorithm(graph, s, d, k);
		
		for (int i = 0; i < paths.size(); i++) {
			int totalWeight = 0;
			System.out.print("Path " + (i + 1) + ": ");
			for (int j = 0; j < paths.get(i).size(); j++) {
				// Calculate the total weight of the path
				if (j <  paths.get(i).size() - 1) {
				totalWeight += graph[paths.get(i).get(j)[0]][paths.get(i).get(j + 1)[0]];
				}
				System.out.print("->" + (paths.get(i).get(j)[0] + 1));
			}
            System.out.print(". ");
			System.out.println("Weight: " + totalWeight);
		}
	}// end ksp
	
	
	/** Yen's algorithm */
	public ArrayList<ArrayList<int[]>> yenAlgorithm(int[][] graph, int s, int d, int n){
		// Node index begin from 0
		s = s - 1;
		d = d - 1;
		ArrayList<ArrayList<int[]>> paths = new ArrayList<>();
		// Determine the shortest path from the source to the sink.
		paths.add(dij(graph, s, d, 0));
		// Initialize the set to store the potential kth shortest path.
		PriorityQueue<ArrayList<int[]>> pq = new PriorityQueue<ArrayList<int[]>>(
				(ArrayList<int[]> a, ArrayList<int[]> b) ->{
					return a.get(a.size() - 1)[1] - b.get(b.size() - 1)[1];
				});
		for (int k = 1; k < n; k++) {
			// The spur node ranges from the first node to the next to last node in the previous k-shortest path.
			for (int i = 0; i <= paths.get(k - 1).size() - 2; i++) {
			    // Spur node is retrieved from the previous k-shortest path, k âˆ’ 1.
				int[] spurNode = paths.get(k - 1).get(i);
			    // The sequence of nodes from the source to the spur node of the previous k-shortest path.
		        ArrayList<int[]> rootPath = new ArrayList<>();
		        // Fill rootPath with nodes from the part of path before spur node
		        for (int m = 0; m <= i; m++) {
		        	rootPath.add(paths.get(k - 1).get(m));
		        }
		        // store the removed links in ArrayList<int[]) for restoring
		        ArrayList<int[]> removedLinks = new ArrayList<>();
		        for (ArrayList<int[]> path: paths) {
		        	// Find if rootPath is within the path
		        	if (isWithin(path, rootPath)) {
		        		// Remove the links that are part of the previous shortest paths which share the same root path.
		        		// Store the link before remove it
		        		if (graph[path.get(i)[0]][path.get(i + 1)[0]] < Integer.MAX_VALUE) {
		        		    removedLinks.add(new int[] {path.get(i)[0], path.get(i + 1)[0], 
		        				graph[path.get(i)[0]][path.get(i + 1)[0]]});
		        		}
		        		// Remove the link
		        		graph[path.get(i)[0]][path.get(i + 1)[0]] = Integer.MAX_VALUE;
		        		graph[path.get(i + 1)[0]][path.get(i)[0]] = Integer.MAX_VALUE;
		        	}	
		        }
	
		        // Remove the nodes in rootPath except spurNode
		        for (int index = 0; index < rootPath.size() - 1; index++) {
        			// Store the link before remove it
		        	if (graph[rootPath.get(index)[0]][rootPath.get(index + 1)[0]] < Integer.MAX_VALUE) {
        			    removedLinks.add(new int[] {rootPath.get(index)[0], rootPath.get(index + 1)[0],
        					graph[rootPath.get(index)[0]][rootPath.get(index + 1)[0]]});
		        	}
        			// Remove the link
        			graph[rootPath.get(index)[0]][rootPath.get(index + 1)[0]] = Integer.MAX_VALUE;
        			graph[rootPath.get(index + 1)[0]][rootPath.get(index)[0]] = Integer.MAX_VALUE;
        		}
		        
		        // Calculate the spur path from the spur node to the sink
		        ArrayList<int[]> spurPath = dij(graph, spurNode[0], d, spurNode[1]);
		     
		        if (spurPath != null) {
		        	// Entire path is made up of the root path and spur path.
			        // totalPath =  = rootPath + spurPath;
		            ArrayList<int[]> totalPath = new ArrayList<>();
		            rootPath.remove(spurNode);
		            totalPath.addAll(rootPath);
		            totalPath.addAll(spurPath);
		               
		            // Add the potential k-shortest path to the PriorityQueue.
		            pq.offer(totalPath);
		        }  
		        // Add back the edges and nodes that were removed from the graph.
		        for (int[] link: removedLinks) {
		        	graph[link[0]][link[1]] = link[2];
		        	graph[link[1]][link[0]] = link[2];
		        }
			}// End of loop i
			if (pq.isEmpty()) {
			    // This handles the case of there being no spur paths, or no spur paths left.
		        // This could happen if the spur paths have already been exhausted (added to A), 
		        // or there are no spur paths at all - such as when both the source and sink vertices 
		        // lie along a "dead end".
		        break;
			}
			
			// Add the lowest cost path becomes the k-shortest path.
			ArrayList<int[]> tempPath = pq.poll();
			while (!pq.isEmpty() && isSame(pq.peek(), tempPath)) {
				pq.poll();
			}
			    paths.add(tempPath);
			
		}// End of loop k
		return paths;
	}
	
	
	/** Check if the two paths are same.
	 * @param path1 ArrayList<int[]> represent one path
	 * @param path2 ArrayList<int[]> represent the other path
	 * @return true is path1 equals path2 else false
	 */
	public boolean isSame(ArrayList<int[]> path1, ArrayList<int[]> path2) {
		if (path1.size() != path2.size() || path1 == null || path2 == null) return false;
		for(int i = 0; i < path1.size(); i++) {
			if(path1.get(i)[0] != path2.get(i)[0]) return false;
		}
		return true;
	}
	
	
	/** Check  if the paths in A contain root path
	 *  @param path ArrayList<int[]> the path in A
	 *  @param rootPath ArrayList<int[]> root path
	 *  @return true if the paths in A contains root path else false */
	public boolean isWithin(ArrayList<int[]> path, ArrayList<int[]> rootPath) {
		if (path.size() < rootPath.size()) {
			return false;
		}
		for (int i = 0; i < rootPath.size(); i++) {
			if (path.get(i)[0] != rootPath.get(i)[0]) {
				return false;
			}
		}
		return true;
		
	}
	
	
	/** Dijkstra's Algorithm to calculate the shortest path from sink to source.
	 * @param graph 2-D array for graph
	 * @param s integer representing the source node
	 * @param d integer representing the sink node
	 * @param initialWeight representing the weight of source node(it is the sum of rootPath weight
	 * @return ArrayList<int[]> to represent the shortest path from source to sink
	 */
	public ArrayList<int[]> dij(int[][] graph, int s, int d, int initialWeight){
		// Fill out the node and weight to infinity
		int[] nodes = new int[graph.length];
		Arrays.fill(nodes, Integer.MAX_VALUE);
		nodes[s] = initialWeight;
		
		
		boolean[] visited = new boolean[graph.length];
		ArrayList<int[]> path = new ArrayList<>();
		// PriorityQueue to store all possible paths from current node and the shortest path
		// will be on the top
		PriorityQueue<ArrayList<int[]>> pq = new PriorityQueue<ArrayList<int[]>>(
				(ArrayList<int[]> a, ArrayList<int[]> b) ->{
					return a.get(a.size() - 1)[1] - b.get(b.size() - 1)[1];
				});
		// Add Source Node to Visited Array and remove the node from unvisited array
		int choseIndex = s;
		path.add(new int[] {choseIndex, nodes[choseIndex]});
		visited[choseIndex] = true;
		while (choseIndex != d) {
			// Get Adjacency vertices
			for (int i = 0 ; i < graph[choseIndex].length; i++) {
				if (!visited[i] && graph[choseIndex][i] > 0) {
					if (nodes[choseIndex] + graph[choseIndex][i] < nodes[i]
							&& nodes[choseIndex] + graph[choseIndex][i] > 0) {
						// Recalculate the weight of adjacency vertices
						nodes[i] = nodes[choseIndex] + graph[choseIndex][i];
						// Concatenate current shortest path with current edges
						ArrayList<int[]> temp = new ArrayList<>();
						temp.addAll(path);
						temp.add(new int[] {i, nodes[i]});
						pq.offer(temp);
					}
				}
			}
			
			if (!pq.isEmpty()) {
				path.addAll(path);
			    path.clear();
			    // choose the shortest path from PriorityQueue and add it to the path
				ArrayList<int[]> temp = pq.poll();
			    path.addAll(temp);
			    // choose next node(the end node of the path) from the shortest path to extend the path
			    choseIndex = temp.get(temp.size() - 1)[0];
			    visited[choseIndex] = true;
			} else { // no more path left
				return null;
			}
		}
		return path;
	}// end dij method
	
	
	/** Implementing the project */
	public static void main(String[] args) {
		// Initialize the object
		Project2 pr = new Project2();
		// Generate graph
		pr.generateEdges();
		// Inputting and Calculating the k shortest paths
		pr.ksp();
	}// end main method

}
